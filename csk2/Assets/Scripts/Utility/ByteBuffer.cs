// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;

namespace com.QH.QPGame.Utility
{
    /// 创建一个可变长的Byte数组方便Push数据和Pop数据
    /// 数组的最大长度为1024,超过会产生溢出
    /// 数组的最大长度由常量MAX_LENGTH设定
    /// 
    /// 注:由于实际需要,可能要从左到右取数据,所以这里
    /// 定义的Pop函数并不是先进后出的函数,而是从0开始.
    /// 
    /// @Author: Red_angelX
    /// 
    public enum ByteOrder
    {
        ByteOrder_BIG_ENDIAN,
        ByteOrder_LITTLE_ENDIAN,
    };

    public class ByteBuffer
    {

        private ByteOrder BYTE_ORDER;

        //数组的最大长度
        private const int MAX_LENGTH = 1024 * 16;

        //固定长度的中间数组
        private byte[] TEMP_BYTE_ARRAY = new byte[MAX_LENGTH];

        //当前数组长度
        private int CURRENT_LENGTH = 0;

        //当前Pop指针位置
        private int CURRENT_POSITION = 0;

        //最后返回数组
        private byte[] RETURN_ARRAY;

        /// <summary>
        /// 默认构造函数
        /// </summary>
        public ByteBuffer()
        {
            this.Initialize();
            BYTE_ORDER = ByteOrder.ByteOrder_LITTLE_ENDIAN;
        }

        /// <summary>
        /// 重载的构造函数,用一个Byte数组来构造
        /// </summary>
        /// <param name="bytes">用于构造ByteBuffer的数组</param>
        public ByteBuffer(byte[] bytes)
        {
            this.Initialize();
            this.PushByteArray(bytes);
			BYTE_ORDER = ByteOrder.ByteOrder_LITTLE_ENDIAN;
        }

        public ByteBuffer(byte[] bytes, int length)
        {
            this.Initialize();
            this.PushByteArray(bytes, 0, length);
			BYTE_ORDER = ByteOrder.ByteOrder_LITTLE_ENDIAN;
        }

        public ByteOrder Order
        {
            get
            {
                return BYTE_ORDER;
            }
            set
            {
                BYTE_ORDER = value;
            }
        }

        /// <summary>
        /// 获取当前ByteBuffer的长度
        /// </summary>
        public int Length
        {
            get
            {
                return CURRENT_LENGTH;
            }
        }

        /// <summary>
        /// 获取/设置当前出栈指针位置
        /// </summary>
        public int Position
        {
            get
            {
                return CURRENT_POSITION;
            }
            set
            {
                CURRENT_POSITION = value;
            }
        }

		public int RemainLength
		{
			get
			{
				return CURRENT_LENGTH - CURRENT_POSITION;
			}
		}

        /// <summary>
        /// 获取ByteBuffer所生成的数组
        /// 长度必须小于 [MAXSIZE]
        /// </summary>
        /// <returns>Byte[]</returns>
        public byte[] ToByteArray()
        {
            //分配大小
            RETURN_ARRAY = new byte[CURRENT_LENGTH];
            //调整指针
            Array.Copy(TEMP_BYTE_ARRAY, 0, RETURN_ARRAY, 0, CURRENT_LENGTH);
            return RETURN_ARRAY;
        }

        public byte[] ToByteArray(int start, int dateSize)
        {
            //分配大小
            RETURN_ARRAY = new byte[dateSize];
            //调整指针
            Array.Copy(TEMP_BYTE_ARRAY, start, RETURN_ARRAY, 0, dateSize);
            return RETURN_ARRAY;
        }




        /// <summary>
        /// 初始化ByteBuffer的每一个元素,并把当前指针指向头一位
        /// </summary>
        public void Initialize()
        {
            TEMP_BYTE_ARRAY.Initialize();
            CURRENT_LENGTH = 0;
            CURRENT_POSITION = 0;
        }

        /// <summary>
        /// 向ByteBuffer压入一个字节
        /// </summary>
        /// <param name="by">一位字节</param>
        public void PushByte(byte by)
        {
            TEMP_BYTE_ARRAY[CURRENT_LENGTH++] = by;
        }

        /// <summary>
        /// 向ByteBuffer压入数组
        /// </summary>
        /// <param name="ByteArray">数组</param>
        public void PushByteArray(byte[] ByteArray)
        {
            //把自己CopyTo目标数组
            ByteArray.CopyTo(TEMP_BYTE_ARRAY, CURRENT_LENGTH);
            //调整长度
            CURRENT_LENGTH += ByteArray.Length;
        }

        public void PushByteArray(byte[] ByteArray, int srcOffset, int byteCount)
        {
            if (srcOffset + byteCount > ByteArray.Length)
            {
                throw new Exception("PushByteArray Exception");
            }
            for (int i = srcOffset; i < srcOffset + byteCount; ++i)
            {
                PushByte(ByteArray[i]);
            }
        }

        /// <summary>
        /// 向ByteBuffer压入两字节的Short
        /// </summary>
        /// <param name="Num">2字节Short</param>
        public void PushUInt16(UInt16 Num)
        {
            TEMP_BYTE_ARRAY[CURRENT_LENGTH++] = (byte)(((Num & 0xff00) >> 8) & 0xff);
            TEMP_BYTE_ARRAY[CURRENT_LENGTH++] = (byte)((Num & 0x00ff) & 0xff);
        }

        /// <summary>
        /// 向ByteBuffer压入一个无符Int值
        /// </summary>
        /// <param name="Num">4字节UInt32</param>
        public void PushInt(UInt32 Num)
        {
            TEMP_BYTE_ARRAY[CURRENT_LENGTH++] = (byte)(((Num & 0xff000000) >> 24) & 0xff);
            TEMP_BYTE_ARRAY[CURRENT_LENGTH++] = (byte)(((Num & 0x00ff0000) >> 16) & 0xff);
            TEMP_BYTE_ARRAY[CURRENT_LENGTH++] = (byte)(((Num & 0x0000ff00) >> 8) & 0xff);
            TEMP_BYTE_ARRAY[CURRENT_LENGTH++] = (byte)((Num & 0x000000ff) & 0xff);
        }

        /// <summary>
        /// 向ByteBuffer压入一个Long值
        /// </summary>
        /// <param name="Num">4字节Long</param>
        public void PushLong(long Num)
        {
            TEMP_BYTE_ARRAY[CURRENT_LENGTH++] = (byte)(((Num & 0xff000000) >> 24) & 0xff);
            TEMP_BYTE_ARRAY[CURRENT_LENGTH++] = (byte)(((Num & 0x00ff0000) >> 16) & 0xff);
            TEMP_BYTE_ARRAY[CURRENT_LENGTH++] = (byte)(((Num & 0x0000ff00) >> 8) & 0xff);
            TEMP_BYTE_ARRAY[CURRENT_LENGTH++] = (byte)((Num & 0x000000ff) & 0xff);
        }

        /// <summary>
        /// 从ByteBuffer的当前位置弹出一个Byte,并提升一位
        /// </summary>
        /// <returns>1字节Byte</returns>
        public byte PopByte()
        {
            byte ret = TEMP_BYTE_ARRAY[CURRENT_POSITION++];
            return ret;
        }

        /// <summary>
        /// 从ByteBuffer的当前位置弹出一个Short,并提升两位
        /// </summary>
        /// <returns>2字节Short</returns>
        public UInt16 PopUInt16()
        {
            //溢出
            if (CURRENT_POSITION + 1 >= CURRENT_LENGTH)
            {
                return 0;
            }

            switch (BYTE_ORDER)
            {
                case ByteOrder.ByteOrder_BIG_ENDIAN:
                    {
                        UInt16 ret = (UInt16)(TEMP_BYTE_ARRAY[CURRENT_POSITION] << 8 | TEMP_BYTE_ARRAY[CURRENT_POSITION + 1]);
                         CURRENT_POSITION += 2;
                        return ret;
                    }
                case ByteOrder.ByteOrder_LITTLE_ENDIAN:
                    {
                        UInt16 ret = (UInt16)(TEMP_BYTE_ARRAY[CURRENT_POSITION + 1] << 8 | TEMP_BYTE_ARRAY[CURRENT_POSITION]);
                        CURRENT_POSITION += 2;
                        return ret;
                    }
            }
            return 0;
        }

        /// <summary>
        /// 从ByteBuffer的当前位置弹出一个uint,并提升4位
        /// </summary>
        /// <returns>4字节UInt</returns>
        public uint PopUInt()
        {
            if (CURRENT_POSITION + 3 >= CURRENT_LENGTH)
                return 0;

            switch (BYTE_ORDER)
            {
                case ByteOrder.ByteOrder_BIG_ENDIAN:
                    {
                        uint ret = (uint)(TEMP_BYTE_ARRAY[CURRENT_POSITION] << 24 | TEMP_BYTE_ARRAY[CURRENT_POSITION + 1] << 16 | TEMP_BYTE_ARRAY[CURRENT_POSITION + 2] << 8 | TEMP_BYTE_ARRAY[CURRENT_POSITION + 3]);
                        CURRENT_POSITION += 4;
                        return ret;
                    }
                case ByteOrder.ByteOrder_LITTLE_ENDIAN:
                    {
                        uint ret = (uint)(TEMP_BYTE_ARRAY[CURRENT_POSITION + 3] << 24 | TEMP_BYTE_ARRAY[CURRENT_POSITION + 2] << 16 | TEMP_BYTE_ARRAY[CURRENT_POSITION + 1] << 8 | TEMP_BYTE_ARRAY[CURRENT_POSITION]);
                        CURRENT_POSITION += 4;
                        return ret;
                    }
            }
            return 0;

        }

        /// <summary>
        /// 从ByteBuffer的当前位置弹出一个long,并提升4位
        /// </summary>
        /// <returns>4字节Long</returns>
        public long PopLong()
        {
            if (CURRENT_POSITION + 3 >= CURRENT_LENGTH)
                return 0;
            switch (BYTE_ORDER)
            {
                case ByteOrder.ByteOrder_BIG_ENDIAN:
                    {
                        uint ret = (uint)(TEMP_BYTE_ARRAY[CURRENT_POSITION] << 24 | TEMP_BYTE_ARRAY[CURRENT_POSITION + 1] << 16 | TEMP_BYTE_ARRAY[CURRENT_POSITION + 2] << 8 | TEMP_BYTE_ARRAY[CURRENT_POSITION + 3]);
                        CURRENT_POSITION += 4;
                        return ret;
                    }
                case ByteOrder.ByteOrder_LITTLE_ENDIAN:
                    {
                        uint ret = (uint)(TEMP_BYTE_ARRAY[CURRENT_POSITION + 3] << 24 | TEMP_BYTE_ARRAY[CURRENT_POSITION + 2] << 16 | TEMP_BYTE_ARRAY[CURRENT_POSITION + 1] << 8 | TEMP_BYTE_ARRAY[CURRENT_POSITION]);
                        CURRENT_POSITION += 4;
                        return ret;
                    }
            }
            return 0;
        }

        /// <summary>
        /// 从ByteBuffer的当前位置弹出长度为Length的Byte数组,提升Length位
        /// </summary>
        /// <param name="Length">数组长度</param>
        /// <returns>Length长度的byte数组</returns>
        public byte[] PopByteArray(int Length)
        {
            //溢出
            if (CURRENT_POSITION + Length > CURRENT_LENGTH)
            {
                return new byte[0];
            }
            byte[] ret = new byte[Length];
            Array.Copy(TEMP_BYTE_ARRAY, CURRENT_POSITION, ret, 0, Length);
            //提升位置
            CURRENT_POSITION += Length;
            return ret;
        }

        public byte[] PopByteArray()
        {
            int Length = CURRENT_LENGTH - CURRENT_POSITION;
            if (Length <= 0)
            {
                return new byte[0];
            }
            byte[] ret = new byte[Length];
            Array.Copy(TEMP_BYTE_ARRAY, CURRENT_POSITION, ret, 0, Length);
            //提升位置
            CURRENT_POSITION += Length;
            return ret;
        }

        public byte Get(Int64 index)
        {
            byte ret = TEMP_BYTE_ARRAY[index];
            return ret;
        }

        public void Put(Int64 index, byte value)
        {
            TEMP_BYTE_ARRAY[index] = value;
        }

        public void PutByte(byte by)
        {
            TEMP_BYTE_ARRAY[CURRENT_POSITION++] = by;

            if (CURRENT_POSITION > CURRENT_LENGTH)
            {
                CURRENT_LENGTH++;
            }
        }

        /// <summary>
        /// 向ByteBuffer压入两字节的Short
        /// </summary>
        /// <param name="Num">2字节Short</param>
        public void PutUInt16(UInt16 Num)
        {
            switch (BYTE_ORDER)
            {
                case ByteOrder.ByteOrder_BIG_ENDIAN:
                    {
                        TEMP_BYTE_ARRAY[CURRENT_POSITION++] = (byte)(((Num & 0xff00) >> 8) & 0xff);
                        TEMP_BYTE_ARRAY[CURRENT_POSITION++] = (byte)((Num & 0x00ff) & 0xff);
                        break;
                    }
                case ByteOrder.ByteOrder_LITTLE_ENDIAN:
                    {
                        TEMP_BYTE_ARRAY[CURRENT_POSITION++] = (byte)((Num & 0x00ff) & 0xff);
                        TEMP_BYTE_ARRAY[CURRENT_POSITION++] = (byte)(((Num & 0xff00) >> 8) & 0xff);
                        break;
                    }
            }

            if (CURRENT_POSITION > CURRENT_LENGTH)
            {
                CURRENT_LENGTH = CURRENT_POSITION;
            }
        }

        public void PutInt(UInt32 Num)
        {
            switch (BYTE_ORDER)
            {
                case ByteOrder.ByteOrder_BIG_ENDIAN:
                    {
                        TEMP_BYTE_ARRAY[CURRENT_POSITION++] = (byte)(((Num & 0xff000000) >> 24) & 0xff);
                        TEMP_BYTE_ARRAY[CURRENT_POSITION++] = (byte)(((Num & 0x00ff0000) >> 16) & 0xff);
                        TEMP_BYTE_ARRAY[CURRENT_POSITION++] = (byte)(((Num & 0x0000ff00) >> 8) & 0xff);
                        TEMP_BYTE_ARRAY[CURRENT_POSITION++] = (byte)((Num & 0x000000ff) & 0xff);
                        break;
                    }
                case ByteOrder.ByteOrder_LITTLE_ENDIAN:
                    {
                        TEMP_BYTE_ARRAY[CURRENT_POSITION++] = (byte)((Num & 0x000000ff) & 0xff);
                        TEMP_BYTE_ARRAY[CURRENT_POSITION++] = (byte)(((Num & 0x0000ff00) >> 8) & 0xff);
                        TEMP_BYTE_ARRAY[CURRENT_POSITION++] = (byte)(((Num & 0x00ff0000) >> 16) & 0xff);
                        TEMP_BYTE_ARRAY[CURRENT_POSITION++] = (byte)(((Num & 0xff000000) >> 24) & 0xff);
                        break;
                    }
            }

            if (CURRENT_POSITION > CURRENT_LENGTH)
            {
                CURRENT_LENGTH = CURRENT_POSITION;
            }
        }

        public void PutLong(long Num)
        {
            switch (BYTE_ORDER)
            {
                case ByteOrder.ByteOrder_BIG_ENDIAN:
                    {
                        TEMP_BYTE_ARRAY[CURRENT_POSITION++] = (byte)(((Num & 0xff000000) >> 24) & 0xff);
                        TEMP_BYTE_ARRAY[CURRENT_POSITION++] = (byte)(((Num & 0x00ff0000) >> 16) & 0xff);
                        TEMP_BYTE_ARRAY[CURRENT_POSITION++] = (byte)(((Num & 0x0000ff00) >> 8) & 0xff);
                        TEMP_BYTE_ARRAY[CURRENT_POSITION++] = (byte)((Num & 0x000000ff) & 0xff);
                        break;
                    }
                case ByteOrder.ByteOrder_LITTLE_ENDIAN:
                    {
                        TEMP_BYTE_ARRAY[CURRENT_POSITION++] = (byte)((Num & 0x000000ff) & 0xff);
                        TEMP_BYTE_ARRAY[CURRENT_POSITION++] = (byte)(((Num & 0x0000ff00) >> 8) & 0xff);
                        TEMP_BYTE_ARRAY[CURRENT_POSITION++] = (byte)(((Num & 0x00ff0000) >> 16) & 0xff);
                        TEMP_BYTE_ARRAY[CURRENT_POSITION++] = (byte)(((Num & 0xff000000) >> 24) & 0xff);
                        break;
                    }
            }
            if (CURRENT_POSITION > CURRENT_LENGTH)
            {
                CURRENT_LENGTH = CURRENT_POSITION;
            }
        }

        public void PutByteArray(byte[] ByteArray, int srcOffset, int byteCount)
        {
            if (srcOffset + byteCount > ByteArray.Length)
            {
                throw new Exception("PushByteArray Exception");
            }
            for (int i = srcOffset; i < srcOffset + byteCount; ++i)
            {
                PutByte(ByteArray[i]);
            }
        }

        public void PutByteArray(byte[] ByteArray)
        {
            for (int i = 0; i < ByteArray.Length; ++i)
            {
                PutByte(ByteArray[i]);
            }
        }

        public void PutIntArray(UInt32[] Array)
        {
            for (int i = 0; i < Array.Length; ++i)
            {
                PutInt(Array[i]);
            }
        }

    }


    public class ByteBufferPool
    {
        private const int MaxPoolSize = 400;
        private static List<ByteBuffer> enablePacket = new List<ByteBuffer>();

        static ByteBufferPool()
        {
        }

        public static void CreatePool()
        {
            lock (((ICollection)enablePacket).SyncRoot)
            {
                enablePacket.Clear();
                for (int i = 0; i < MaxPoolSize; i++)
                {
                    enablePacket.Add(new ByteBuffer());
                }
            }
        }

        public static ByteBuffer PopPacket()
        {
            lock (((ICollection)enablePacket).SyncRoot)
            {
                if (enablePacket.Count > 0)
                {
                    var packet = enablePacket[0];
                    enablePacket.Remove(packet);
                    packet.Initialize();
                    return packet;
                }
                else
                {
                    //Debug.Log("#################### new packet !!!!!!!!!!!!!!:" + System.Environment.TickCount.ToString());
                    return new ByteBuffer();
                }
            }
        }

        public static ByteBuffer PopPacket(byte[] data, int len)
        {
            lock (((ICollection)enablePacket).SyncRoot)
            {
                if (enablePacket.Count > 0)
                {
                    var usePacket = enablePacket[0];
                    enablePacket.Remove(usePacket);
                    usePacket.PushByteArray(data, 0, len);
                    return usePacket;
                }
                else
                {
                    //Debug.Log("#################### new packet !!!!!!!!!!!!!!:" + System.Environment.TickCount.ToString());
                    return new ByteBuffer(data, len);
                }
            }
        }

        public static ByteBuffer PopPacket(byte[] data)
        {
            lock (((ICollection)enablePacket).SyncRoot)
            {
                if (enablePacket.Count > 0)
                {
                    var usePacket = enablePacket[0];
                    enablePacket.Remove(usePacket);
                    usePacket.Initialize();
                    usePacket.PushByteArray(data, 0, data.Length);
                    return usePacket;
                }
                else
                {
                    //Debug.Log("#################### new packet !!!!!!!!!!!!!!:" + System.Environment.TickCount.ToString());
                    return new ByteBuffer(data);
                }
            }
        }

        public static void DropPacket(ByteBuffer packet)
        {
            lock (((ICollection)enablePacket).SyncRoot)
            {
                if (enablePacket.Count < MaxPoolSize)
                {
                    packet.Initialize();
                    enablePacket.Add(packet);
                }
            }
        }
    }
}

